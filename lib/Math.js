// Generated by CoffeeScript 1.3.2
var math,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

math = (function() {

  function math() {
    this.intersectTri = __bind(this.intersectTri, this);

    this.unProj = __bind(this.unProj, this);

    this.cross = __bind(this.cross, this);

    this.dot = __bind(this.dot, this);

    this.add = __bind(this.add, this);

    this.subtract = __bind(this.subtract, this);

    this.magnitude = __bind(this.magnitude, this);

  }

  math.prototype.magnitude = function(v1, v2) {
    return Math.pow(Math.pow(v1[0] + v2[0], 2) + Math.pow(v1[1] + v2[1], 2) + Math.pow(v1[2] + v2[2], 2), 0.5);
  };

  math.prototype.subtract = function(v1, v2) {
    if (v1.length === !v2.length) {
      return null;
    } else if (v1.length === 2) {
      return [v1[0] - v2[0], v1[1] - v2[1]];
    } else if (v1.length === 3) {
      return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
    } else if (v1.length === 3) {
      return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2], v1[3] - v2[3]];
    }
  };

  math.prototype.add = function(v1, v2) {
    if (v1.length === !v2.length) {
      return null;
    } else if (v1.length === 2) {
      return [v1[0] + v2[0], v1[1] + v2[1]];
    } else if (v1.length === 3) {
      return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
    } else if (v1.length === 3) {
      return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2], v1[3] + v2[3]];
    }
  };

  math.prototype.dot = function(v1, v2) {
    if (v1.length === !v2.length) {
      return null;
    } else if (v1.length === 2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    } else if (v1.length === 3) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    } else if (v1.length === 3) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2] + v1[3] * v2[3];
    }
  };

  math.prototype.cross = function(v1, v2) {
    return [v1[0] * v2[2] - v1[2] * v2[0], v1[2] * v2[0] - v1[0] * v2[2], v1[0] * v2[1] - v1[1] * v2[0]];
  };

  math.prototype.unProj = function(winX, winY, winZ, mod_mat, proj_mat, viewport) {
    var inf, m, out;
    inf = [];
    m = mat4.set(mod_mat, mat4.create());
    mat4.inverse(m, m);
    mat4.multiply(proj_mat, m, m);
    mat4.inverse(m, m);
    inf.push((winX - viewport[0]) / viewport[2] * 2.0 - 1.0);
    inf.push((winY - viewport[1]) / viewport[3] * 2.0 - 1.0);
    inf.push(2 * winZ - 1.0);
    inf.push(1.0);
    out = [0, 0, 0, 0];
    mat4.multiplyVec4(m, inf, out);
    if (out[3] === 0) {
      return null;
    }
    out[3] = 1.0 / out[3];
    return [out[0] * out[3], out[1] * out[3], out[2] * out[3]];
  };

  math.prototype.intersectTri = function(position, direction, triangle) {
    var E_1, E_2, Q, T, v_0, v_1, v_2;
    v_0 = triangle[0];
    v_1 = triangle[1];
    v_2 = triangle[2];
    E_1 = this.subtract(v_1, v_0);
    E_2 = this.subtract(v_2, v_0);
    T = this.subtract(position, v_0);
    Q = this.cross(T, E_1);
  };

  return math;

})();
