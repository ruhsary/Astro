// Generated by CoffeeScript 1.3.2
var HTM,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

HTM = (function() {

  HTM.verts = null;

  HTM.VertexPositionBuffer = null;

  HTM.VertexColorBuffer = null;

  function HTM(levels, gl) {
    this.levels = levels;
    this.gl = gl;
    this.render = __bind(this.render, this);

    this.bind = __bind(this.bind, this);

    this.subdivide = __bind(this.subdivide, this);

    this.magnitude = __bind(this.magnitude, this);

    this.createHTM = __bind(this.createHTM, this);

    this.debugColor = __bind(this.debugColor, this);

    this.createHTM();
  }

  HTM.prototype.debugColor = function() {
    var color, colors, depth, j, k, l, num, _i, _j, _k, _l, _len, _len1, _len2;
    color = [];
    colors = [[[1.0, 0.0, 0.0, 1.0], [1.0, 0.0, 0.0, 1.0], [1.0, 0.0, 0.0, 1.0]], [[0.0, 1.0, 0.0, 1.0], [0.0, 1.0, 0.0, 1.0], [0.0, 1.0, 0.0, 1.0]], [[0.0, 0.0, 1.0, 1.0], [0.0, 0.0, 1.0, 1.0], [0.0, 0.0, 1.0, 1.0]], [[1.0, 1.0, 0.0, 1.0], [1.0, 1.0, 0.0, 1.0], [1.0, 1.0, 0.0, 1.0]], [[1.0, 0.0, 1.0, 1.0], [1.0, 0.0, 1.0, 1.0], [1.0, 0.0, 1.0, 1.0]], [[0.0, 1.0, 1.0, 1.0], [0.0, 1.0, 1.0, 1.0], [0.0, 1.0, 1.0, 1.0]], [[1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0]], [[0.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 1.0]]];
    depth = Math.pow(4, this.levels);
    for (num = _i = depth; depth <= 0 ? _i <= 0 : _i >= 0; num = depth <= 0 ? ++_i : --_i) {
      for (_j = 0, _len = colors.length; _j < _len; _j++) {
        j = colors[_j];
        for (_k = 0, _len1 = j.length; _k < _len1; _k++) {
          k = j[_k];
          for (_l = 0, _len2 = k.length; _l < _len2; _l++) {
            l = k[_l];
            color.push(l);
          }
        }
      }
    }
    this.VertexColorBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexColorBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(color), this.gl.STATIC_DRAW);
    this.VertexColorBuffer.itemSize = 4;
    this.VertexColorBuffer.numItems = 8 * Math.pow(4, this.levels) * 3;
  };

  HTM.prototype.createHTM = function() {
    var component, initTriangles, triangles, vert, _i, _j, _k, _l, _len, _len1, _len2, _len3;
    this.verts = [];
    initTriangles = [[[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]], [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]], [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]], [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]], [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]], [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]], [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]], [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]];
    if (this.levels === 0) {
      for (_i = 0, _len = initTriangles.length; _i < _len; _i++) {
        triangles = initTriangles[_i];
        for (_j = 0, _len1 = triangles.length; _j < _len1; _j++) {
          vert = triangles[_j];
          for (_k = 0, _len2 = vert.length; _k < _len2; _k++) {
            component = vert[_k];
            this.verts.push(component);
          }
        }
      }
    } else {
      for (_l = 0, _len3 = initTriangles.length; _l < _len3; _l++) {
        triangles = initTriangles[_l];
        this.subdivide(triangles, this.levels - 1);
      }
    }
    this.VertexPositionBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.verts), this.gl.STATIC_DRAW);
    this.VertexPositionBuffer.itemSize = 3;
    this.VertexPositionBuffer.numItems = 8 * Math.pow(4, this.levels) * 3;
    this.debugColor();
  };

  HTM.prototype.magnitude = function(v1, v2) {
    return Math.pow(Math.pow(v1[0] + v2[0], 2) + Math.pow(v1[1] + v2[1], 2) + Math.pow(v1[2] + v2[2], 2), 0.5);
  };

  HTM.prototype.subdivide = function(v, l) {
    var component, mag, newTriangles, triangles, vert, w0, w1, w2, _i, _j, _k, _l, _len, _len1, _len2, _len3;
    mag = this.magnitude(v[1], v[2]);
    w0 = [];
    w0.push((v[1][0] + v[2][0]) / mag);
    if (!(w0[0] != null)) {
      w0[0] = 0;
    }
    w0.push((v[1][1] + v[2][1]) / mag);
    if (!(w0[1] != null)) {
      w0[1] = 0;
    }
    w0.push((v[1][2] + v[2][2]) / mag);
    if (!(w0[2] != null)) {
      w0[2] = 0;
    }
    mag = this.magnitude(v[0], v[2]);
    w1 = [];
    w1.push((v[0][0] + v[2][0]) / mag);
    if (!(w1[0] != null)) {
      w1[0] = 0;
    }
    w1.push((v[0][1] + v[2][1]) / mag);
    if (!(w1[1] != null)) {
      w1[1] = 0;
    }
    w1.push((v[0][2] + v[2][2]) / mag);
    if (!(w1[2] != null)) {
      w1[2] = 0;
    }
    mag = this.magnitude(v[0], v[1]);
    w2 = [];
    w2.push((v[0][0] + v[1][0]) / mag);
    if (!(w2[0] != null)) {
      w2[0] = 0;
    }
    w2.push((v[0][1] + v[1][1]) / mag);
    if (!(w2[1] != null)) {
      w2[1] = 0;
    }
    w2.push((v[0][2] + v[1][2]) / mag);
    if (!(w2[2] != null)) {
      w2[2] = 0;
    }
    newTriangles = [[v[0], w2, w1], [v[1], w0, w2], [v[2], w1, w0], [w0, w1, w2]];
    if (l === 0) {
      for (_i = 0, _len = newTriangles.length; _i < _len; _i++) {
        triangles = newTriangles[_i];
        for (_j = 0, _len1 = triangles.length; _j < _len1; _j++) {
          vert = triangles[_j];
          for (_k = 0, _len2 = vert.length; _k < _len2; _k++) {
            component = vert[_k];
            this.verts.push(component);
          }
        }
      }
    } else {
      for (_l = 0, _len3 = newTriangles.length; _l < _len3; _l++) {
        triangles = newTriangles[_l];
        this.subdivide(triangles, l - 1);
      }
    }
  };

  HTM.prototype.bind = function(gl, shaderProgram) {
    gl.bindBuffer(gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, this.VertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.VertexColorBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, this.VertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
  };

  HTM.prototype.render = function(gl, renderMode) {
    gl.drawArrays(renderMode, 0, this.VertexPositionBuffer.numItems);
  };

  return HTM;

})();
