// Generated by CoffeeScript 1.3.2
var BoxOverlay, View,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

View = (function() {

  function View(container) {
    this.panScroll = __bind(this.panScroll, this);

    this.panUp = __bind(this.panUp, this);

    this.panMove = __bind(this.panMove, this);

    this.panDown = __bind(this.panDown, this);

    this.cleanBox = __bind(this.cleanBox, this);

    this.imageRequestManager = __bind(this.imageRequestManager, this);

    this.getBoundingBox = __bind(this.getBoundingBox, this);

    this.notify = __bind(this.notify, this);

    this.register = __bind(this.register, this);

    this.display = __bind(this.display, this);

    this.setState = __bind(this.setState, this);

    this.setScale = __bind(this.setScale, this);

    this.addScale = __bind(this.addScale, this);

    this.jump = __bind(this.jump, this);

    this.translate = __bind(this.translate, this);

    var click,
      _this = this;
    this.handlers = {
      'translate': null,
      'scale': null,
      'box': null
    };
    this.mouseStateUp = this.panUp;
    this.state = 0;
    this.mouseStateDown = this.panDown;
    this.mouseStateMove = this.panMove;
    this.mouseCoords = {
      x: 0,
      y: 0
    };
    this.canvas = document.createElement("canvas");
    this.canvas.width = container.clientWidth;
    this.canvas.height = container.clientHeight;
    this.canvas.style.backgroundColor = "rgb(0,0,0)";
    this.map = {};
    this.mouseHandler(this.canvas);
    this.ctx = this.canvas.getContext('2d');
    this.ctx.globalCompositeOperation = "lighter";
    container.appendChild(this.canvas);
    this.observers = [];
    this.position = {
      x: 0.0,
      y: 0.0
    };
    this.pixelTranslation = {
      x: this.canvas.width / 2,
      y: this.canvas.height / 2
    };
    this.scale = 1.8;
    this.range = {
      lowX: 0,
      lowY: 0,
      highX: 0,
      highY: 0
    };
    this.register('translate', this.imageRequestManager);
    this.register('box', this.cleanBox);
    this.imageRequestManager();
    this.box = new BoxOverlay(this.canvas, this);
    click = function() {
      _this.display();
      return setTimeout(click, 1000);
    };
    click();
  }

  /*
  	translate
  	Translates X degrees, Y Degrees.
  	Not pixels! Degrees! Going translate(0,1) is a full degree, which is 2 images.
  	Compounds each translate
  	Triggers: 'translate' event
  */


  View.prototype.translate = function(x, y) {
    this.position.x += x;
    this.position.y += y;
    return this.notify('translate', this.position);
  };

  View.prototype.jump = function(x, y) {
    this.position.x = x;
    this.position.y = y;
    return this.notify('translate', this.position);
  };

  View.prototype.addScale = function(addScale) {
    this.scale += addScale;
    this.notify('scale', this.scale);
    return this.display();
  };

  View.prototype.setScale = function(newScale) {
    this.scale = newScale;
    this.notify('scale', this.scale);
    return this.display();
  };

  View.prototype.setState = function(newState) {
    this.state = newState;
    this.unhookEvent(this.canvas, "mousedown", this.mouseStateDown);
    this.unhookEvent(this.canvas, "mouseup", this.mouseStateUp);
    this.unhookEvent(this.canvas, "mousemove", this.mouseStateMove);
    this.unhookEvent(this.canvas, "mousewheel", this.mousewheel);
    if (newState === 1) {
      return this.box.setEvents();
    } else {
      this.mouseStateUp = this.panUp;
      this.mouseStateDown = this.panDown;
      this.mouseStateMove = this.panMove;
      this.hookEvent(this.canvas, "mousedown", this.mouseStateDown);
      this.hookEvent(this.canvas, "mouseup", this.mouseStateUp);
      this.hookEvent(this.canvas, "mousemove", this.mouseStateMove);
      return this.hookEvent(this.canvas, "mousewheel", this.mousewheel);
    }
  };

  View.prototype.display = function() {
    var i, j, overlay, zoom, _i, _len, _ref;
    this.ctx.save();
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.translate(this.pixelTranslation.x, this.pixelTranslation.y);
    zoom = 1.8 / this.scale;
    this.ctx.translate(-512 * zoom, -512 * zoom);
    this.ctx.translate(this.position.x / .512 * 1024 * zoom, -this.position.y / .512 * 1024 * zoom);
    this.ctx.scale(zoom, zoom);
    i = this.range.lowX;
    while (i <= this.range.highX) {
      j = this.range.lowY;
      while (j < this.range.highY) {
        _ref = this.observers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          overlay = _ref[_i];
          overlay.update("display", {
            x: i,
            y: j,
            ctx: this.ctx
          });
        }
        j++;
      }
      i++;
    }
    this.ctx.restore();
    if (this.state === 1) {
      return this.box.display();
    }
  };

  View.prototype.attach = function(observer) {
    this.observers.push(observer);
    return this.updateState(observer);
  };

  View.prototype.detach = function(observer) {
    var overlay, _i, _len, _ref, _results;
    _ref = this.observers;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      overlay = _ref[_i];
      if (overlay === observer) {
        overlay.setAlpha(0);
        overlay = null;
        break;
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  View.prototype.register = function(type, callback) {
    var oldLoaded;
    oldLoaded = this.handlers[type];
    if (this.handlers[type]) {
      return this.handlers[type] = function(view) {
        if (oldLoaded) {
          oldLoaded(view);
        }
        return callback(view);
      };
    } else {
      return this.handlers[type] = callback;
    }
  };

  View.prototype.notify = function(type, info) {
    if (this.handlers[type]) {
      return this.handlers[type](info);
    }
  };

  View.prototype.getCoordinate = function(x, y) {
    var degreeHeight, degreePoint, degreeWidth, pixelHeight, pixelWidth;
    if (!((this.pixelTranslation.x != null) && (this.pixelTranslation.y != null) && (this.position.x != null) && (this.position.y != null))) {
      return null;
    }
    pixelWidth = x - this.pixelTranslation.x;
    pixelHeight = y - this.pixelTranslation.y;
    /*Pixels*arcsec/pixel = arcsec per difference. 1 degree = 3600 arcseconds
    */

    degreeWidth = pixelWidth * this.scale / 3600.0;
    degreeHeight = pixelHeight * this.scale / 3600.0;
    degreePoint = {
      'x': this.position.x - degreeWidth,
      'y': this.position.y + degreeHeight
    };
    return degreePoint;
  };

  View.prototype.getBoundingBox = function() {
    var rangeX, rangeY;
    rangeX = this.canvas.width * this.scale / 3600.0 * 2;
    rangeY = this.canvas.height * this.scale / 3600.0 * 2;
    this.range.maxRA = Math.ceil((this.position.x + rangeX) / .512);
    this.range.minRA = Math.floor((this.position.x - rangeX) / .512);
    this.range.maxDec = Math.ceil((this.position.y + rangeY) / .512);
    this.range.minDec = Math.floor((this.position.y - rangeY) / .512);
    return range;
  };

  /*
  	Function: imageRequestManager
  	Use: Private function to manage translation and requesting images.
  	Hooked on construction to the translate event handler
  */


  View.prototype.imageRequestManager = function() {
    var Mx, i, j, overlay, rangeX, rangeY, spacing, xp, yp, _i, _len, _ref;
    rangeX = this.canvas.width * this.scale / 3600.0 * 2;
    rangeY = this.canvas.height * this.scale / 3600.0 * 2;
    this.range.highX = Math.ceil((this.position.x + rangeX) / .512);
    this.range.lowX = Math.floor((this.position.x - rangeX) / .512);
    this.range.highY = Math.ceil((this.position.y + rangeY) / .512);
    this.range.lowY = Math.floor((this.position.y - rangeY) / .512);
    if (this.range.lowX < 0) {
      this.range.lowX = 0;
    }
    j = this.range.lowY;
    while (j <= this.range.highY) {
      i = this.range.lowX;
      Mx = 0;
      while (i <= this.range.highX) {
        if ((this.map[i] != null) && this.map[i][j]) {
          i++;
          continue;
        } else {
          if (Mx === 0) {
            yp = j * 0.512;
            spacing = 0.512 / Math.cos(yp * Math.PI / 180.0);
            Mx = Math.ceil(i * 0.512 / spacing);
            xp = Mx * spacing;
            console.log(xp, yp, Mx, j, spacing);
          } else {
            Mx++;
            xp = Mx * spacing;
          }
          _ref = this.observers;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            overlay = _ref[_i];
            overlay.update('request', {
              x: i,
              y: j,
              RA: xp,
              Dec: yp
            });
          }
          if (this.map[i] != null) {
            this.map[i][j] = true;
          } else {
            this.map[i] = {};
            this.map[i][j] = true;
          }
        }
        i++;
      }
      j++;
    }
    return this.display();
  };

  View.prototype.cleanBox = function() {
    this.box.enabled = true;
    return this.setState(0);
  };

  View.prototype.updateState = function(observer) {
    var Mx, i, j, spacing, xp, yp, _results;
    _results = [];
    for (j in this.map) {
      Mx = 0;
      _results.push((function() {
        var _results1;
        _results1 = [];
        for (i in this.map[j]) {
          if (Mx === 0) {
            yp = j * 0.512;
            spacing = 0.512 / Math.cos(yp * Math.PI / 180.0);
            Mx = Math.ceil(i * 0.512 / spacing);
            xp = Mx * spacing;
            console.log(xp, yp, Mx, j, spacing);
          } else {
            Mx++;
            xp = Mx * spacing;
          }
          _results1.push(observer.update('request', {
            x: i,
            y: j,
            RA: xp,
            Dec: yp
          }));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  View.prototype.mouseHandler = function(canvas) {
    this.hookEvent(canvas, "mousedown", this.panDown);
    this.hookEvent(canvas, "mouseup", this.panUp);
    this.hookEvent(canvas, "mousewheel", this.panScroll);
    this.hookEvent(canvas, "mousemove", this.panMove);
    this.mouseStateUp = this.panUp;
    this.mouseStateDown = this.panDown;
    return this.mouseStateMove = this.panMove;
  };

  View.prototype.panDown = function(event) {
    this.mouseState = 1;
    this.mouseCoords.x = event.clientX;
    return this.mouseCoords.y = event.clientY;
  };

  View.prototype.panMove = function(event) {
    if (this.mouseState === 1) {
      this.translate((event.clientX - this.mouseCoords.x) / 1000 * 1.8 / this.scale, (-event.clientY + this.mouseCoords.y) / 1000 * 1.8 / this.scale);
      this.mouseCoords.x = event.clientX;
      return this.mouseCoords.y = event.clientY;
    }
  };

  View.prototype.panUp = function(event) {
    this.mouseState = 0;
    return this.imageRequestManager();
  };

  View.prototype.panScroll = function(event) {
    var delta;
    delta = 0;
    if (!event) {
      event = window.event;
    }
    if (event.wheelDelta) {
      delta = event.wheelDelta / 60;
    } else if (event.detail) {
      delta = -event.detail / 2;
    }
    if (delta > 0 && this.scale >= 1.8) {
      this.addScale(-.3);
    } else if (delta <= 0) {
      this.addScale(.3);
    }
    return this.imageRequestManager();
  };

  View.prototype.hookEvent = function(element, eventName, callback) {
    if (typeof element === "string") {
      element = document.getElementById(element);
    }
    if (element === null) {
      return;
    }
    if (element.addEventListener) {
      if (eventName === 'mousewheel') {
        element.addEventListener('DOMMouseScroll', callback, false);
      }
      return element.addEventListener(eventName, callback, false);
    } else if (element.attachEvent) {
      return element.attachEvent("on" + eventName, callback);
    }
  };

  View.prototype.unhookEvent = function(element, eventName, callback) {
    if (typeof element === "string") {
      element = document.getElementById(element);
    }
    if (element === null) {
      return;
    }
    if (element.removeEventListener) {
      if (eventName === 'mousewheel') {
        element.removeEventListener('DOMMouseScroll', callback, false);
      }
      return element.removeEventListener(eventName, callback, false);
    } else if (element.detachEvent) {
      return element.detachEvent("on" + eventName, callback);
    }
  };

  return View;

})();

BoxOverlay = (function() {

  function BoxOverlay(canvas, view) {
    var _this = this;
    this.canvas = canvas;
    this.ctx = this.canvas.getContext('2d');
    this.ctx.fillStyle = "rgba(0,0,200,.5)";
    this.start = 0;
    this.draw = false;
    this.enabled = true;
    this.end = 0;
    this.view = view;
    this.onBox = null;
    this.canvas.relMouseCoords = function(event) {
      var canvasX, canvasY, currentElement, totalOffsetX, totalOffsetY;
      totalOffsetX = 0;
      totalOffsetY = 0;
      canvasX = 0;
      canvasY = 0;
      currentElement = this;
      while (currentElement = currentElement.offsetParent) {
        totalOffsetX += currentElement.offsetLeft;
        totalOffsetY += currentElement.offsetTop;
      }
      canvasX = event.pageX - totalOffsetX;
      canvasY = event.pageY - totalOffsetY;
      return {
        x: canvasX,
        y: canvasY
      };
    };
    this.boxdown = function(event) {
      if (!_this.enabled) {
        return;
      }
      _this.start = _this.canvas.relMouseCoords(event);
      return _this.draw = true;
    };
    this.boxmove = function(event) {
      if (_this.draw && _this.enabled) {
        _this.end = _this.canvas.relMouseCoords(event);
        return _this.view.display();
      }
    };
    this.boxup = function(event) {
      var drawEnd;
      if (!_this.enabled) {
        return;
      }
      _this.end = _this.canvas.relMouseCoords(event);
      _this.view.notify('box', {
        start: _this.view.getCoordinate(_this.start.x, _this.start.y),
        end: _this.view.getCoordinate(_this.end.x, _this.end.y)
      });
      _this.enabled = false;
      drawEnd = function() {
        return this.draw = false;
      };
      return setTimeout(drawEnd, 1000);
    };
  }

  BoxOverlay.prototype.setEvents = function() {
    this.view.mouseStateUp = this.boxup;
    this.view.mouseStateDown = this.boxdown;
    this.view.mouseStateMove = this.boxmove;
    View.prototype.hookEvent(this.canvas, "mousedown", this.boxdown);
    View.prototype.hookEvent(this.canvas, "mouseup", this.boxup);
    return View.prototype.hookEvent(this.canvas, "mousemove", this.boxmove);
  };

  BoxOverlay.prototype.display = function() {
    if (this.draw) {
      this.ctx.fillRect(this.start.x, this.start.y, this.end.x - this.start.x, this.end.y - this.start.y);
      return console.log(this.start.x, this.start.y, this.end.x, this.end.y);
    }
  };

  return BoxOverlay;

})();
